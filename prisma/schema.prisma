// Tells Prisma to generate TypeScript code
generator client {
  provider = "prisma-client-js"
}

// Points to the Neon PostgreSQL database (using the connection string from .env)
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ENUMS (Fixed choices)
enum MediaType {
  MOVIE
  TV
  BOOK
  GAME
}

// MODELS (Tables)

// User: Stores account information
model User {
  id           String   @id @default(cuid())
  username     String   @unique // Public identifier for social features
  name         String? // Optional: user can add later
  email        String   @unique // Must be unique, required for login
  passwordHash String // Encrypted password
  avatarUrl    String? // Optional: profile picture
  bio          String?  @db.Text // Profile bio (for future social features)
  createdAt    DateTime @default(now()) // Auto-set on creation
  updatedAt    DateTime @updatedAt // Auto-updated on changes

    // Relationships
  logEntries LogEntry[] // One user can have many log entries
  accounts   Account[]  // One user can have multiple login methods (Google + email)
  sessions   Session[]  // One user can be logged in on multiple devices
}

// MediaItem: Stores details about movies, TV, books, games
model MediaItem {
  id            String    @id @default(cuid())
  type          MediaType // Enum: MOVIE, TV, BOOK, or GAME
  title         String // Required: every media has a title
  year          Int? // Optional: some media lacks clear release year
  creators      Json? // Optional: Array like ["Lana Wachowski", "Lilly Wachowski"]
  coverImageUrl String? // Optional: poster/cover image URL
  description   String?   @db.Text // Optional: plot summary (Text = longer text)
  metadataJson  Json? // Optional: flexible extra data from APIs
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relationships
  logEntries   LogEntry[] // Many users can log this media
  mediaSources MediaSource[] // This media can exist on multiple platforms
}

// LogEntry: Records when a user logs watching/reading/playing something
model LogEntry {
  id          String    @id @default(cuid())
  userId      String // Foreign key to User
  mediaItemId String // Foreign key to MediaItem
  rating      Decimal?  @db.Decimal(2, 1) // Optional: 0.0 to 5.0 (one decimal place)
  note        String?   @db.Text // Optional: user's personal thoughts
  loggedAt    DateTime  @default(now()) // Auto-set when user clicks "Log"
  consumedOn  DateTime? // Optional: when they actually watched/read/played it

  // Relationships
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  mediaItem MediaItem @relation(fields: [mediaItemId], references: [id], onDelete: Cascade)

  @@index([userId]) // Makes searching by user faster
  @@index([mediaItemId]) // Makes searching by media faster
}

// MediaSource: Connects media items to external databases (IMDb, RAWG, etc.)
model MediaSource {
  id          String   @id @default(cuid())
  mediaItemId String // Foreign key to MediaItem
  provider    String // e.g., "IMDb", "RAWG", "OpenLibrary"
  externalId  String // The ID on that platform (e.g., "tt0133093")
  externalUrl String? // Optional: direct link to source
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relationships
  mediaItem MediaItem @relation(fields: [mediaItemId], references: [id], onDelete: Cascade)

  @@unique([mediaItemId, provider]) // One media can't have duplicate providers
  @@index([provider, externalId]) // Makes searching by external ID faster
}

// NEXTAUTH.JS MODELS (for authentication)

// Account: Stores OAuth connections (Google, GitHub, etc.)
// When a user signs in with Google, NextAuth creates an Account record
model Account {
  id                String  @id @default(cuid())
  userId            String  // Links to User
  type              String  // "oauth" or "credentials"
  provider          String  // "google", "github", etc.
  providerAccountId String  // User's ID on that provider (Google's unique ID for them)
  refresh_token     String? @db.Text // OAuth refresh token (optional)
  access_token      String? @db.Text // OAuth access token (optional)
  expires_at        Int? // When the access token expires (timestamp)
  token_type        String? // "Bearer", etc.
  scope             String? // OAuth scopes granted
  id_token          String? @db.Text // OAuth ID token (optional)
  session_state     String? // OAuth session state (optional)

  // Relationship: Each Account belongs to one User
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Ensure one user can't have duplicate providers
  @@unique([provider, providerAccountId])
  @@index([userId]) // Makes searching by user faster
}

// Session: Tracks who's currently logged in
// When you log in, NextAuth creates a Session record with an expiry date
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique // Random token stored in user's cookie
  userId       String   // Links to User
  expires      DateTime // When this session expires (e.g., 30 days from now)

  // Relationship: Each Session belongs to one User
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId]) // Makes searching by user faster
}

// VerificationToken: Used for email verification & password resets
// When you request a password reset, NextAuth creates a temporary token
model VerificationToken {
  identifier String   // Usually an email address
  token      String   @unique // Random token sent to user's email
  expires    DateTime // When this token expires (e.g., 24 hours)

  // Composite unique: Same email can't have duplicate active tokens
  @@unique([identifier, token])
}

